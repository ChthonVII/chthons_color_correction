# chthons_color_correction

This is a retroarch shader with three main features:
1. CRT color correction simulation and state-of-the-art gamut conversion to sRGB using LUTS generated by [gamutthingy](https://github.com/ChthonVII/gamutthingy).
2. Unique approach to scanline and aperature grille shaders that has minimal impact on color and brightness.
3. Scanline, etc. shaders are applied over a fully upscaled source, making it possible to "cheat" in extra interpolated resolution, or even edge-smoothing like super-xbr.

For information on CRT color correction simulation and gamut conversion, see [gamutthingy's readme](https://github.com/ChthonVII/gamutthingy).

Scanline and aperature grille shaders usually wreck color and brightness. Most of them work by darkening certain pixels, roughly compensating with an arbitrary global brightness boost, and clipping boosted colors that exceed 100%. Color and brightness are thus mangled, and so all of the effort that went into accurately reproducing the CRT's color correction behavior and color gamut is wasted. This shader aims to do better.

The key idea here is that, instead of just darkening pixels, we *move* units of linear RGB from one pixel to another. For scanlines, we move them to form a guassian shape, and for aperature grille we move them segregate colors into subpixels. In both instances, the amount moved is limited by the smaller of how much color the "donor" pixels have to give or how much headroom the "recipient" pixels have open to receive. Consequently, the average brightness and average color are preserved over the local area involved in each operation. And, given adequate viewing distance, brightness and color do not appear to change.

One important caveat: This only works to the extent that your monitor faithfully reproduces the sRGB gamma function. If it does not, you will get brightness and color distortions at full strength, especially with the aperature grille effect. On some monitors, it may be neccessary to turn down the strength of the aperature grille effect to 30% or even lower.

To give credit where credit is due, I did not think this up all by myself. The core idea was inspired by how [crt-beans](https://github.com/aduffey/crt-beans) works.

The halation/diffusion implementation is also a bit different than usual, again in order to better preserve color and brightness. The halation strength scales with the luminosity difference of the colors, so that very bright colors bleed onto very dark colors, but the effect tapers off so that colors of similar luminosity are barely affected.

The scanline and aperature grille effects are applied over a fully upscaled source. This means that you can upscale with interpolation to get "extra" resolution and some of that will be visibly preserved despite the scanline and aperature grille effects. Two upscaling options are implemented here: super-xbr upscaling, as a vivid demonstration of this property, and reverse-aa, which is used in Hyllian's pixel-art CRT preset. You can replace these with any upscaling implementation you want. Or you can even use bilinear, or even nearest neighbor, if you want to be 100% faithful to the original pixels.

There is no bezel effect or rounded corners or whatnot, but feel free to add them.

### Usage ###

Set Retroarch's scale mode to "full" and turn integer scaling off. Set the core's scaling to 1:1 PAR (i.e., square pixels).

If using BSNES with mode7 scaling, enable "supersampling." (This poorly named option means that BSNES will supersample using the resolution you specify, but always output 1x resolution.)

Presets with "NES" in the name are meant to be used with an NES emulator and a palette file generated by gamutthingy. The CRT simulation and gamut conversion and compression is baked into the palette file.

Presets with "TEMPLATE" in the name are templates for making new presets. They won't run because the file name for SamplerLUT isn't defined.

To make a new preset, run gamutthingy to generate a LUT and set the `--retroarchtextoutputfile` parameter, paste the LUT file into the `luts` subdirectory, and paste the content of the output text file into one of the templates.

There are four types of templates:
- LUTtype1 is suitable for LUTs made with gamutthingy's `--lutmode normal`.
- LUTtype1fast is also suitble for LUTs made with gamutthingy's `--lutmode normal`. It sacrifices some accuracy in calculating the relative distances to interpolate between the 8 nearest LUT entries in exchange for speed. (Probably not enough to have any impact after RGB8 quantization though.)
- LUTtype2 is suitable for LUTs made with gamutthingy's `--lutmode postcc`.
- LUTtype3 is suitable for LUTs made with gamutthingy's `--lutmode postgamma`.

Presets are generally named with "raa" or "sxbr" to indicate the upscaling method (reverse-aa or super-xbr), a country code, and a name or description of the CRT.
For example, `CCC-sxbr-JP-trinitron-01.slangp` uses super-xbr upscaling and simulates a Japanese trinitron (and is the first of several planned trinitron presets).
